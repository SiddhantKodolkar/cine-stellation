"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/components/MovieData.js":
/*!*****************************************!*\
  !*** ./src/app/components/MovieData.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useMoviesData)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _s = $RefreshSig$();\n\n// Optional: genre color mapping\nconst genreColors = {\n    Comedy: '#f1fa8c',\n    'Sci-Fi': '#8be9fd',\n    Adventure: '#50fa7b',\n    Animation: '#bd93f9',\n    Children: '#ff79c6',\n    Fantasy: '#ffb86c',\n    Romance: '#ff5555',\n    Drama: '#6272a4',\n    Thriller: '#ff79c6',\n    Mystery: '#ffb86c'\n};\nfunction getColor(genres) {\n    // Pick first genre that has a color, fallback to gray\n    for (const g of genres){\n        if (genreColors[g]) return genreColors[g];\n    }\n    return '#cccccc';\n}\n// Force-directed positioning algorithm\nfunction applyForceLayout(movies) {\n    let iterations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;\n    // Clone movies to avoid mutating the original array during iterations\n    const nodes = JSON.parse(JSON.stringify(movies));\n    const k = 30; // Optimal distance between nodes\n    const canvasWidth = window.innerWidth;\n    const canvasHeight = window.innerHeight;\n    // Start with a larger spread across the canvas\n    nodes.forEach((node, i)=>{\n        // Distribute in a grid-like pattern initially\n        const gridSize = Math.ceil(Math.sqrt(nodes.length));\n        const col = i % gridSize;\n        const row = Math.floor(i / gridSize);\n        // Spread across 80% of the canvas\n        const spreadX = canvasWidth * 0.8;\n        const spreadY = canvasHeight * 0.8;\n        node.x = canvasWidth * 0.1 + col / gridSize * spreadX;\n        node.y = canvasHeight * 0.1 + row / gridSize * spreadY;\n        // Initialize velocity components\n        node.vx = 0;\n        node.vy = 0;\n    });\n    // Run simulation for a fixed number of iterations\n    for(let iter = 0; iter < iterations; iter++){\n        // Calculate repulsive forces between all nodes\n        for(let i = 0; i < nodes.length; i++){\n            for(let j = i + 1; j < nodes.length; j++){\n                const node1 = nodes[i];\n                const node2 = nodes[j];\n                // Calculate distance between nodes\n                const dx = node2.x - node1.x;\n                const dy = node2.y - node1.y;\n                const distance = Math.sqrt(dx * dx + dy * dy) || 1; // Avoid division by zero\n                // Calculate repulsive force (inversely proportional to distance)\n                let force = k * k / distance;\n                // If nodes are similar, reduce repulsive force (keep them closer)\n                if (node1.similarTo && node1.similarTo.includes(node2.id)) {\n                    const similarity = node1.similarityScores[node2.id] || 0.5;\n                    force *= 1 - similarity * 0.7; // Reduce force based on similarity\n                }\n                // Apply force along the distance vector\n                if (distance > 0) {\n                    const forceX = dx / distance * force;\n                    const forceY = dy / distance * force;\n                    node1.vx -= forceX;\n                    node1.vy -= forceY;\n                    node2.vx += forceX;\n                    node2.vy += forceY;\n                }\n            }\n        }\n        // Apply attractive forces for connected nodes\n        for(let i = 0; i < nodes.length; i++){\n            const node = nodes[i];\n            if (node.similarTo && node.similarTo.length > 0) {\n                for (const targetId of node.similarTo){\n                    const targetNode = nodes.find((n)=>n.id === targetId);\n                    if (targetNode) {\n                        const dx = targetNode.x - node.x;\n                        const dy = targetNode.y - node.y;\n                        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n                        // Attractive force proportional to distance\n                        const similarity = node.similarityScores[targetId] || 0.5;\n                        const force = distance * similarity * 0.05;\n                        if (distance > 0) {\n                            const forceX = dx / distance * force;\n                            const forceY = dy / distance * force;\n                            node.vx += forceX;\n                            node.vy += forceY;\n                        }\n                    }\n                }\n            }\n        }\n        // Update positions and apply velocity damping\n        for (const node of nodes){\n            node.x += node.vx;\n            node.y += node.vy;\n            // Add boundary forces to keep nodes within canvas\n            const padding = 50;\n            if (node.x < padding) node.vx += 1;\n            if (node.x > canvasWidth - padding) node.vx -= 1;\n            if (node.y < padding) node.vy += 1;\n            if (node.y > canvasHeight - padding) node.vy -= 1;\n            // Dampen velocity for next iteration\n            node.vx *= 0.9;\n            node.vy *= 0.9;\n        }\n    }\n    // Final step: make sure nodes don't overlap\n    for(let i = 0; i < nodes.length; i++){\n        for(let j = i + 1; j < nodes.length; j++){\n            const node1 = nodes[i];\n            const node2 = nodes[j];\n            const dx = node2.x - node1.x;\n            const dy = node2.y - node1.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            // Minimum allowed distance between node centers (sum of radii plus margin)\n            const minDistance = node1.radius + node2.radius + 5;\n            if (distance < minDistance) {\n                // Move nodes apart along their connecting line\n                const overlap = minDistance - distance;\n                const moveX = dx / distance * overlap * 0.5;\n                const moveY = dy / distance * overlap * 0.5;\n                node1.x -= moveX;\n                node1.y -= moveY;\n                node2.x += moveX;\n                node2.y += moveY;\n            }\n        }\n    }\n    return nodes;\n}\nfunction useMoviesData() {\n    _s();\n    const [movies, setMovies] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMoviesData.useEffect\": ()=>{\n            async function fetchData() {\n                try {\n                    const res = await fetch('/constellation_data.json');\n                    const raw = await res.json();\n                    // Map of movieId => movieData\n                    const movieMap = {};\n                    raw.movies.forEach({\n                        \"useMoviesData.useEffect.fetchData\": (movie)=>{\n                            movieMap[movie.id] = movie;\n                        }\n                    }[\"useMoviesData.useEffect.fetchData\"]);\n                    // Prepare similarity lookup: movieId => { similarTo: [...], similarityScores: {...} }\n                    const similarityMap = {};\n                    raw.connections.forEach({\n                        \"useMoviesData.useEffect.fetchData\": (conn)=>{\n                            if (!similarityMap[conn.source]) {\n                                similarityMap[conn.source] = {\n                                    similarTo: [],\n                                    similarityScores: {}\n                                };\n                            }\n                            similarityMap[conn.source].similarTo.push(conn.target);\n                            similarityMap[conn.source].similarityScores[conn.target] = conn.similarity;\n                            // Bidirectional (optional depending on your logic)\n                            if (!similarityMap[conn.target]) {\n                                similarityMap[conn.target] = {\n                                    similarTo: [],\n                                    similarityScores: {}\n                                };\n                            }\n                            similarityMap[conn.target].similarTo.push(conn.source);\n                            similarityMap[conn.target].similarityScores[conn.source] = conn.similarity;\n                        }\n                    }[\"useMoviesData.useEffect.fetchData\"]);\n                    // First pass: create movie objects with basic properties\n                    const processedMovies = raw.movies.map({\n                        \"useMoviesData.useEffect.fetchData.processedMovies\": (movie)=>{\n                            const { similarTo = [], similarityScores = {} } = similarityMap[movie.id] || {};\n                            return {\n                                id: movie.id,\n                                title: movie.title,\n                                year: movie.year || \"\",\n                                x: 0,\n                                y: 0,\n                                radius: 8 + Math.min(5, similarTo.length / 3),\n                                color: getColor(movie.genres),\n                                genres: movie.genres,\n                                similarTo,\n                                similarityScores,\n                                // Add visibility property for fade effects\n                                visibility: 1\n                            };\n                        }\n                    }[\"useMoviesData.useEffect.fetchData.processedMovies\"]);\n                    // Apply force-directed layout\n                    const positionedMovies = applyForceLayout(processedMovies);\n                    setMovies(positionedMovies);\n                } catch (err) {\n                    console.error('Failed to load constellation data:', err);\n                }\n            }\n            fetchData();\n        }\n    }[\"useMoviesData.useEffect\"], []);\n    return movies;\n}\n_s(useMoviesData, \"MO6b3PSP3RIUqZ8gtSrBZBVtBbs=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9Nb3ZpZURhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUM0QztBQUU1QyxnQ0FBZ0M7QUFDaEMsTUFBTUUsY0FBYztJQUNsQkMsUUFBUTtJQUNSLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLFVBQVU7SUFDVkMsU0FBUztJQUNUQyxTQUFTO0lBQ1RDLE9BQU87SUFDUEMsVUFBVTtJQUNWQyxTQUFTO0FBQ1g7QUFFQSxTQUFTQyxTQUFTQyxNQUFNO0lBQ3RCLHNEQUFzRDtJQUN0RCxLQUFLLE1BQU1DLEtBQUtELE9BQVE7UUFDdEIsSUFBSVgsV0FBVyxDQUFDWSxFQUFFLEVBQUUsT0FBT1osV0FBVyxDQUFDWSxFQUFFO0lBQzNDO0lBQ0EsT0FBTztBQUNUO0FBRUEsdUNBQXVDO0FBQ3ZDLFNBQVNDLGlCQUFpQkMsTUFBTTtRQUFFQyxhQUFBQSxpRUFBYTtJQUM3QyxzRUFBc0U7SUFDdEUsTUFBTUMsUUFBUUMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxTQUFTLENBQUNMO0lBQ3hDLE1BQU1NLElBQUksSUFBSSxpQ0FBaUM7SUFDL0MsTUFBTUMsY0FBY0MsT0FBT0MsVUFBVTtJQUNyQyxNQUFNQyxlQUFlRixPQUFPRyxXQUFXO0lBRXZDLCtDQUErQztJQUMvQ1QsTUFBTVUsT0FBTyxDQUFDLENBQUNDLE1BQU1DO1FBQ25CLDhDQUE4QztRQUM5QyxNQUFNQyxXQUFXQyxLQUFLQyxJQUFJLENBQUNELEtBQUtFLElBQUksQ0FBQ2hCLE1BQU1pQixNQUFNO1FBQ2pELE1BQU1DLE1BQU1OLElBQUlDO1FBQ2hCLE1BQU1NLE1BQU1MLEtBQUtNLEtBQUssQ0FBQ1IsSUFBSUM7UUFFM0Isa0NBQWtDO1FBQ2xDLE1BQU1RLFVBQVVoQixjQUFjO1FBQzlCLE1BQU1pQixVQUFVZCxlQUFlO1FBRS9CRyxLQUFLWSxDQUFDLEdBQUcsY0FBZSxNQUFPLE1BQU9WLFdBQVlRO1FBQ2xEVixLQUFL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QnNEIiwic291cmNlcyI6WyIvaG9tZS9zYWhhL2JkYTI1L2NpbmUtc3RlbGxhdGlvbi9jaW5lLXN0ZWxsYXRpb24vY2xpZW50L3NyYy9hcHAvY29tcG9uZW50cy9Nb3ZpZURhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vLyBPcHRpb25hbDogZ2VucmUgY29sb3IgbWFwcGluZ1xuY29uc3QgZ2VucmVDb2xvcnMgPSB7XG4gIENvbWVkeTogJyNmMWZhOGMnLFxuICAnU2NpLUZpJzogJyM4YmU5ZmQnLFxuICBBZHZlbnR1cmU6ICcjNTBmYTdiJyxcbiAgQW5pbWF0aW9uOiAnI2JkOTNmOScsXG4gIENoaWxkcmVuOiAnI2ZmNzljNicsXG4gIEZhbnRhc3k6ICcjZmZiODZjJyxcbiAgUm9tYW5jZTogJyNmZjU1NTUnLFxuICBEcmFtYTogJyM2MjcyYTQnLFxuICBUaHJpbGxlcjogJyNmZjc5YzYnLFxuICBNeXN0ZXJ5OiAnI2ZmYjg2YycsXG59O1xuXG5mdW5jdGlvbiBnZXRDb2xvcihnZW5yZXMpIHtcbiAgLy8gUGljayBmaXJzdCBnZW5yZSB0aGF0IGhhcyBhIGNvbG9yLCBmYWxsYmFjayB0byBncmF5XG4gIGZvciAoY29uc3QgZyBvZiBnZW5yZXMpIHtcbiAgICBpZiAoZ2VucmVDb2xvcnNbZ10pIHJldHVybiBnZW5yZUNvbG9yc1tnXTtcbiAgfVxuICByZXR1cm4gJyNjY2NjY2MnO1xufVxuXG4vLyBGb3JjZS1kaXJlY3RlZCBwb3NpdGlvbmluZyBhbGdvcml0aG1cbmZ1bmN0aW9uIGFwcGx5Rm9yY2VMYXlvdXQobW92aWVzLCBpdGVyYXRpb25zID0gNTApIHtcbiAgLy8gQ2xvbmUgbW92aWVzIHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbCBhcnJheSBkdXJpbmcgaXRlcmF0aW9uc1xuICBjb25zdCBub2RlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobW92aWVzKSk7XG4gIGNvbnN0IGsgPSAzMDsgLy8gT3B0aW1hbCBkaXN0YW5jZSBiZXR3ZWVuIG5vZGVzXG4gIGNvbnN0IGNhbnZhc1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIGNvbnN0IGNhbnZhc0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgXG4gIC8vIFN0YXJ0IHdpdGggYSBsYXJnZXIgc3ByZWFkIGFjcm9zcyB0aGUgY2FudmFzXG4gIG5vZGVzLmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICAvLyBEaXN0cmlidXRlIGluIGEgZ3JpZC1saWtlIHBhdHRlcm4gaW5pdGlhbGx5XG4gICAgY29uc3QgZ3JpZFNpemUgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KG5vZGVzLmxlbmd0aCkpO1xuICAgIGNvbnN0IGNvbCA9IGkgJSBncmlkU2l6ZTtcbiAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKGkgLyBncmlkU2l6ZSk7XG4gICAgXG4gICAgLy8gU3ByZWFkIGFjcm9zcyA4MCUgb2YgdGhlIGNhbnZhc1xuICAgIGNvbnN0IHNwcmVhZFggPSBjYW52YXNXaWR0aCAqIDAuODtcbiAgICBjb25zdCBzcHJlYWRZID0gY2FudmFzSGVpZ2h0ICogMC44O1xuICAgIFxuICAgIG5vZGUueCA9IChjYW52YXNXaWR0aCAqIDAuMSkgKyAoY29sIC8gZ3JpZFNpemUpICogc3ByZWFkWDtcbiAgICBub2RlLnkgPSAoY2FudmFzSGVpZ2h0ICogMC4xKSArIChyb3cgLyBncmlkU2l6ZSkgKiBzcHJlYWRZO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdmVsb2NpdHkgY29tcG9uZW50c1xuICAgIG5vZGUudnggPSAwO1xuICAgIG5vZGUudnkgPSAwO1xuICB9KTtcblxuICAvLyBSdW4gc2ltdWxhdGlvbiBmb3IgYSBmaXhlZCBudW1iZXIgb2YgaXRlcmF0aW9uc1xuICBmb3IgKGxldCBpdGVyID0gMDsgaXRlciA8IGl0ZXJhdGlvbnM7IGl0ZXIrKykge1xuICAgIC8vIENhbGN1bGF0ZSByZXB1bHNpdmUgZm9yY2VzIGJldHdlZW4gYWxsIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZTEgPSBub2Rlc1tpXTtcbiAgICAgICAgY29uc3Qgbm9kZTIgPSBub2Rlc1tqXTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBiZXR3ZWVuIG5vZGVzXG4gICAgICAgIGNvbnN0IGR4ID0gbm9kZTIueCAtIG5vZGUxLng7XG4gICAgICAgIGNvbnN0IGR5ID0gbm9kZTIueSAtIG5vZGUxLnk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSB8fCAxOyAvLyBBdm9pZCBkaXZpc2lvbiBieSB6ZXJvXG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgcmVwdWxzaXZlIGZvcmNlIChpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIGRpc3RhbmNlKVxuICAgICAgICBsZXQgZm9yY2UgPSBrICogayAvIGRpc3RhbmNlO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgbm9kZXMgYXJlIHNpbWlsYXIsIHJlZHVjZSByZXB1bHNpdmUgZm9yY2UgKGtlZXAgdGhlbSBjbG9zZXIpXG4gICAgICAgIGlmIChub2RlMS5zaW1pbGFyVG8gJiYgbm9kZTEuc2ltaWxhclRvLmluY2x1ZGVzKG5vZGUyLmlkKSkge1xuICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBub2RlMS5zaW1pbGFyaXR5U2NvcmVzW25vZGUyLmlkXSB8fCAwLjU7XG4gICAgICAgICAgZm9yY2UgKj0gKDEgLSBzaW1pbGFyaXR5ICogMC43KTsgLy8gUmVkdWNlIGZvcmNlIGJhc2VkIG9uIHNpbWlsYXJpdHlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQXBwbHkgZm9yY2UgYWxvbmcgdGhlIGRpc3RhbmNlIHZlY3RvclxuICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgY29uc3QgZm9yY2VYID0gKGR4IC8gZGlzdGFuY2UpICogZm9yY2U7XG4gICAgICAgICAgY29uc3QgZm9yY2VZID0gKGR5IC8gZGlzdGFuY2UpICogZm9yY2U7XG4gICAgICAgICAgXG4gICAgICAgICAgbm9kZTEudnggLT0gZm9yY2VYO1xuICAgICAgICAgIG5vZGUxLnZ5IC09IGZvcmNlWTtcbiAgICAgICAgICBub2RlMi52eCArPSBmb3JjZVg7XG4gICAgICAgICAgbm9kZTIudnkgKz0gZm9yY2VZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFwcGx5IGF0dHJhY3RpdmUgZm9yY2VzIGZvciBjb25uZWN0ZWQgbm9kZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZS5zaW1pbGFyVG8gJiYgbm9kZS5zaW1pbGFyVG8ubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldElkIG9mIG5vZGUuc2ltaWxhclRvKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IG5vZGVzLmZpbmQobiA9PiBuLmlkID09PSB0YXJnZXRJZCk7XG4gICAgICAgICAgaWYgKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gdGFyZ2V0Tm9kZS54IC0gbm9kZS54O1xuICAgICAgICAgICAgY29uc3QgZHkgPSB0YXJnZXROb2RlLnkgLSBub2RlLnk7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgfHwgMTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXR0cmFjdGl2ZSBmb3JjZSBwcm9wb3J0aW9uYWwgdG8gZGlzdGFuY2VcbiAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBub2RlLnNpbWlsYXJpdHlTY29yZXNbdGFyZ2V0SWRdIHx8IDAuNTtcbiAgICAgICAgICAgIGNvbnN0IGZvcmNlID0gZGlzdGFuY2UgKiBzaW1pbGFyaXR5ICogMC4wNTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBmb3JjZVggPSAoZHggLyBkaXN0YW5jZSkgKiBmb3JjZTtcbiAgICAgICAgICAgICAgY29uc3QgZm9yY2VZID0gKGR5IC8gZGlzdGFuY2UpICogZm9yY2U7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBub2RlLnZ4ICs9IGZvcmNlWDtcbiAgICAgICAgICAgICAgbm9kZS52eSArPSBmb3JjZVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbnMgYW5kIGFwcGx5IHZlbG9jaXR5IGRhbXBpbmdcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIG5vZGUueCArPSBub2RlLnZ4O1xuICAgICAgbm9kZS55ICs9IG5vZGUudnk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBib3VuZGFyeSBmb3JjZXMgdG8ga2VlcCBub2RlcyB3aXRoaW4gY2FudmFzXG4gICAgICBjb25zdCBwYWRkaW5nID0gNTA7XG4gICAgICBpZiAobm9kZS54IDwgcGFkZGluZykgbm9kZS52eCArPSAxO1xuICAgICAgaWYgKG5vZGUueCA+IGNhbnZhc1dpZHRoIC0gcGFkZGluZykgbm9kZS52eCAtPSAxO1xuICAgICAgaWYgKG5vZGUueSA8IHBhZGRpbmcpIG5vZGUudnkgKz0gMTtcbiAgICAgIGlmIChub2RlLnkgPiBjYW52YXNIZWlnaHQgLSBwYWRkaW5nKSBub2RlLnZ5IC09IDE7XG4gICAgICBcbiAgICAgIC8vIERhbXBlbiB2ZWxvY2l0eSBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgIG5vZGUudnggKj0gMC45O1xuICAgICAgbm9kZS52eSAqPSAwLjk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBGaW5hbCBzdGVwOiBtYWtlIHN1cmUgbm9kZXMgZG9uJ3Qgb3ZlcmxhcFxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IG5vZGUxID0gbm9kZXNbaV07XG4gICAgICBjb25zdCBub2RlMiA9IG5vZGVzW2pdO1xuICAgICAgXG4gICAgICBjb25zdCBkeCA9IG5vZGUyLnggLSBub2RlMS54O1xuICAgICAgY29uc3QgZHkgPSBub2RlMi55IC0gbm9kZTEueTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIFxuICAgICAgLy8gTWluaW11bSBhbGxvd2VkIGRpc3RhbmNlIGJldHdlZW4gbm9kZSBjZW50ZXJzIChzdW0gb2YgcmFkaWkgcGx1cyBtYXJnaW4pXG4gICAgICBjb25zdCBtaW5EaXN0YW5jZSA9IG5vZGUxLnJhZGl1cyArIG5vZGUyLnJhZGl1cyArIDU7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgIC8vIE1vdmUgbm9kZXMgYXBhcnQgYWxvbmcgdGhlaXIgY29ubmVjdGluZyBsaW5lXG4gICAgICAgIGNvbnN0IG92ZXJsYXAgPSBtaW5EaXN0YW5jZSAtIGRpc3RhbmNlO1xuICAgICAgICBjb25zdCBtb3ZlWCA9IChkeCAvIGRpc3RhbmNlKSAqIG92ZXJsYXAgKiAwLjU7XG4gICAgICAgIGNvbnN0IG1vdmVZID0gKGR5IC8gZGlzdGFuY2UpICogb3ZlcmxhcCAqIDAuNTtcbiAgICAgICAgXG4gICAgICAgIG5vZGUxLnggLT0gbW92ZVg7XG4gICAgICAgIG5vZGUxLnkgLT0gbW92ZVk7XG4gICAgICAgIG5vZGUyLnggKz0gbW92ZVg7XG4gICAgICAgIG5vZGUyLnkgKz0gbW92ZVk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gbm9kZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZU1vdmllc0RhdGEoKSB7XG4gIGNvbnN0IFttb3ZpZXMsIHNldE1vdmllc10gPSB1c2VTdGF0ZShbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2NvbnN0ZWxsYXRpb25fZGF0YS5qc29uJyk7XG4gICAgICAgIGNvbnN0IHJhdyA9IGF3YWl0IHJlcy5qc29uKCk7XG5cbiAgICAgICAgLy8gTWFwIG9mIG1vdmllSWQgPT4gbW92aWVEYXRhXG4gICAgICAgIGNvbnN0IG1vdmllTWFwID0ge307XG4gICAgICAgIHJhdy5tb3ZpZXMuZm9yRWFjaChtb3ZpZSA9PiB7XG4gICAgICAgICAgbW92aWVNYXBbbW92aWUuaWRdID0gbW92aWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFByZXBhcmUgc2ltaWxhcml0eSBsb29rdXA6IG1vdmllSWQgPT4geyBzaW1pbGFyVG86IFsuLi5dLCBzaW1pbGFyaXR5U2NvcmVzOiB7Li4ufSB9XG4gICAgICAgIGNvbnN0IHNpbWlsYXJpdHlNYXAgPSB7fTtcbiAgICAgICAgcmF3LmNvbm5lY3Rpb25zLmZvckVhY2goY29ubiA9PiB7XG4gICAgICAgICAgaWYgKCFzaW1pbGFyaXR5TWFwW2Nvbm4uc291cmNlXSkge1xuICAgICAgICAgICAgc2ltaWxhcml0eU1hcFtjb25uLnNvdXJjZV0gPSB7IHNpbWlsYXJUbzogW10sIHNpbWlsYXJpdHlTY29yZXM6IHt9IH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpbWlsYXJpdHlNYXBbY29ubi5zb3VyY2VdLnNpbWlsYXJUby5wdXNoKGNvbm4udGFyZ2V0KTtcbiAgICAgICAgICBzaW1pbGFyaXR5TWFwW2Nvbm4uc291cmNlXS5zaW1pbGFyaXR5U2NvcmVzW2Nvbm4udGFyZ2V0XSA9IGNvbm4uc2ltaWxhcml0eTtcblxuICAgICAgICAgIC8vIEJpZGlyZWN0aW9uYWwgKG9wdGlvbmFsIGRlcGVuZGluZyBvbiB5b3VyIGxvZ2ljKVxuICAgICAgICAgIGlmICghc2ltaWxhcml0eU1hcFtjb25uLnRhcmdldF0pIHtcbiAgICAgICAgICAgIHNpbWlsYXJpdHlNYXBbY29ubi50YXJnZXRdID0geyBzaW1pbGFyVG86IFtdLCBzaW1pbGFyaXR5U2NvcmVzOiB7fSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaW1pbGFyaXR5TWFwW2Nvbm4udGFyZ2V0XS5zaW1pbGFyVG8ucHVzaChjb25uLnNvdXJjZSk7XG4gICAgICAgICAgc2ltaWxhcml0eU1hcFtjb25uLnRhcmdldF0uc2ltaWxhcml0eVNjb3Jlc1tjb25uLnNvdXJjZV0gPSBjb25uLnNpbWlsYXJpdHk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpcnN0IHBhc3M6IGNyZWF0ZSBtb3ZpZSBvYmplY3RzIHdpdGggYmFzaWMgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRNb3ZpZXMgPSByYXcubW92aWVzLm1hcChtb3ZpZSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBzaW1pbGFyVG8gPSBbXSwgc2ltaWxhcml0eVNjb3JlcyA9IHt9IH0gPSBzaW1pbGFyaXR5TWFwW21vdmllLmlkXSB8fCB7fTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IG1vdmllLmlkLFxuICAgICAgICAgICAgdGl0bGU6IG1vdmllLnRpdGxlLFxuICAgICAgICAgICAgeWVhcjogbW92aWUueWVhciB8fCBcIlwiLCAvLyBBZGQgeWVhciBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIHg6IDAsIC8vIFdpbGwgYmUgcG9zaXRpb25lZCBieSBmb3JjZSBsYXlvdXRcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICByYWRpdXM6IDggKyBNYXRoLm1pbig1LCAoc2ltaWxhclRvLmxlbmd0aCAvIDMpKSwgLy8gUmFkaXVzIGJhc2VkIG9uIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICBjb2xvcjogZ2V0Q29sb3IobW92aWUuZ2VucmVzKSxcbiAgICAgICAgICAgIGdlbnJlczogbW92aWUuZ2VucmVzLFxuICAgICAgICAgICAgc2ltaWxhclRvLFxuICAgICAgICAgICAgc2ltaWxhcml0eVNjb3JlcyxcbiAgICAgICAgICAgIC8vIEFkZCB2aXNpYmlsaXR5IHByb3BlcnR5IGZvciBmYWRlIGVmZmVjdHNcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IDFcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IGZvcmNlLWRpcmVjdGVkIGxheW91dFxuICAgICAgICBjb25zdCBwb3NpdGlvbmVkTW92aWVzID0gYXBwbHlGb3JjZUxheW91dChwcm9jZXNzZWRNb3ZpZXMpO1xuICAgICAgICBcbiAgICAgICAgc2V0TW92aWVzKHBvc2l0aW9uZWRNb3ZpZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNvbnN0ZWxsYXRpb24gZGF0YTonLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZldGNoRGF0YSgpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIG1vdmllcztcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImdlbnJlQ29sb3JzIiwiQ29tZWR5IiwiQWR2ZW50dXJlIiwiQW5pbWF0aW9uIiwiQ2hpbGRyZW4iLCJGYW50YXN5IiwiUm9tYW5jZSIsIkRyYW1hIiwiVGhyaWxsZXIiLCJNeXN0ZXJ5IiwiZ2V0Q29sb3IiLCJnZW5yZXMiLCJnIiwiYXBwbHlGb3JjZUxheW91dCIsIm1vdmllcyIsIml0ZXJhdGlvbnMiLCJub2RlcyIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImsiLCJjYW52YXNXaWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJpbm5lckhlaWdodCIsImZvckVhY2giLCJub2RlIiwiaSIsImdyaWRTaXplIiwiTWF0aCIsImNlaWwiLCJzcXJ0IiwibGVuZ3RoIiwiY29sIiwicm93IiwiZmxvb3IiLCJzcHJlYWRYIiwic3ByZWFkWSIsIngiLCJ5IiwidngiLCJ2eSIsIml0ZXIiLCJqIiwibm9kZTEiLCJub2RlMiIsImR4IiwiZHkiLCJkaXN0YW5jZSIsImZvcmNlIiwic2ltaWxhclRvIiwiaW5jbHVkZXMiLCJpZCIsInNpbWlsYXJpdHkiLCJzaW1pbGFyaXR5U2NvcmVzIiwiZm9yY2VYIiwiZm9yY2VZIiwidGFyZ2V0SWQiLCJ0YXJnZXROb2RlIiwiZmluZCIsIm4iLCJwYWRkaW5nIiwibWluRGlzdGFuY2UiLCJyYWRpdXMiLCJvdmVybGFwIiwibW92ZVgiLCJtb3ZlWSIsInVzZU1vdmllc0RhdGEiLCJzZXRNb3ZpZXMiLCJmZXRjaERhdGEiLCJyZXMiLCJmZXRjaCIsInJhdyIsImpzb24iLCJtb3ZpZU1hcCIsIm1vdmllIiwic2ltaWxhcml0eU1hcCIsImNvbm5lY3Rpb25zIiwiY29ubiIsInNvdXJjZSIsInB1c2giLCJ0YXJnZXQiLCJwcm9jZXNzZWRNb3ZpZXMiLCJtYXAiLCJ0aXRsZSIsInllYXIiLCJtaW4iLCJjb2xvciIsInZpc2liaWxpdHkiLCJwb3NpdGlvbmVkTW92aWVzIiwiZXJyIiwiY29uc29sZSIsImVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/MovieData.js\n"));

/***/ })

});