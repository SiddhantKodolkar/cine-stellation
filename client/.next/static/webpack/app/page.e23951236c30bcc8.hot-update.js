"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/components/MovieData.js":
/*!*****************************************!*\
  !*** ./src/app/components/MovieData.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useMoviesData)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _s = $RefreshSig$();\n\n// Optional: genre color mapping\nconst genreColors = {\n    Comedy: '#f1fa8c',\n    'Sci-Fi': '#8be9fd',\n    Adventure: '#50fa7b',\n    Animation: '#bd93f9',\n    Children: '#ff79c6',\n    Fantasy: '#ffb86c',\n    Romance: '#ff5555',\n    Drama: '#6272a4',\n    Thriller: '#ff79c6',\n    Mystery: '#ffb86c'\n};\nfunction getColor(genres) {\n    // Pick first genre that has a color, fallback to gray\n    for (const g of genres){\n        if (genreColors[g]) return genreColors[g];\n    }\n    return '#cccccc';\n}\n// Force-directed positioning algorithm\nfunction applyForceLayout(movies) {\n    let iterations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;\n    const nodes = JSON.parse(JSON.stringify(movies));\n    const k = 15; // smaller optimal distance => tighter layout\n    const canvasWidth = window.innerWidth;\n    const canvasHeight = window.innerHeight;\n    nodes.forEach((node, i)=>{\n        const gridSize = Math.ceil(Math.sqrt(nodes.length));\n        const col = i % gridSize;\n        const row = Math.floor(i / gridSize);\n        const spreadX = canvasWidth * 0.4; // reduced spread\n        const spreadY = canvasHeight * 0.4;\n        node.x = canvasWidth * 0.3 + col / gridSize * spreadX;\n        node.y = canvasHeight * 0.3 + row / gridSize * spreadY;\n        node.vx = 0;\n        node.vy = 0;\n    });\n    for(let iter = 0; iter < iterations; iter++){\n        for(let i = 0; i < nodes.length; i++){\n            for(let j = i + 1; j < nodes.length; j++){\n                const node1 = nodes[i];\n                const node2 = nodes[j];\n                const dx = node2.x - node1.x;\n                const dy = node2.y - node1.y;\n                const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n                let force = k * k / distance;\n                if (node1.similarTo && node1.similarTo.includes(node2.id)) {\n                    const similarity = node1.similarityScores[node2.id] || 0.5;\n                    force *= 1 - similarity * 0.7;\n                }\n                if (distance > 0) {\n                    const forceX = dx / distance * force;\n                    const forceY = dy / distance * force;\n                    node1.vx -= forceX;\n                    node1.vy -= forceY;\n                    node2.vx += forceX;\n                    node2.vy += forceY;\n                }\n            }\n        }\n        for(let i = 0; i < nodes.length; i++){\n            const node = nodes[i];\n            if (node.similarTo && node.similarTo.length > 0) {\n                for (const targetId of node.similarTo){\n                    const targetNode = nodes.find((n)=>n.id === targetId);\n                    if (targetNode) {\n                        const dx = targetNode.x - node.x;\n                        const dy = targetNode.y - node.y;\n                        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n                        const similarity = node.similarityScores[targetId] || 0.5;\n                        const force = distance * similarity * 0.07; // slightly stronger attraction\n                        if (distance > 0) {\n                            const forceX = dx / distance * force;\n                            const forceY = dy / distance * force;\n                            node.vx += forceX;\n                            node.vy += forceY;\n                        }\n                    }\n                }\n            }\n        }\n        for (const node of nodes){\n            node.x += node.vx;\n            node.y += node.vy;\n            const padding = 20; // tighter boundary\n            if (node.x < padding) node.vx += 1;\n            if (node.x > canvasWidth - padding) node.vx -= 1;\n            if (node.y < padding) node.vy += 1;\n            if (node.y > canvasHeight - padding) node.vy -= 1;\n            node.vx *= 0.9;\n            node.vy *= 0.9;\n        }\n    }\n    for(let i = 0; i < nodes.length; i++){\n        for(let j = i + 1; j < nodes.length; j++){\n            const node1 = nodes[i];\n            const node2 = nodes[j];\n            const dx = node2.x - node1.x;\n            const dy = node2.y - node1.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            const minDistance = node1.radius + node2.radius + 3;\n            if (distance < minDistance) {\n                const overlap = minDistance - distance;\n                const moveX = dx / distance * overlap * 0.5;\n                const moveY = dy / distance * overlap * 0.5;\n                node1.x -= moveX;\n                node1.y -= moveY;\n                node2.x += moveX;\n                node2.y += moveY;\n            }\n        }\n    }\n    return nodes;\n}\nfunction useMoviesData() {\n    _s();\n    const [movies, setMovies] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMoviesData.useEffect\": ()=>{\n            async function fetchData() {\n                try {\n                    const res = await fetch('/constellation_data.json');\n                    const raw = await res.json();\n                    // Map of movieId => movieData\n                    const movieMap = {};\n                    raw.movies.forEach({\n                        \"useMoviesData.useEffect.fetchData\": (movie)=>{\n                            movieMap[movie.id] = movie;\n                        }\n                    }[\"useMoviesData.useEffect.fetchData\"]);\n                    // Prepare similarity lookup: movieId => { similarTo: [...], similarityScores: {...} }\n                    const similarityMap = {};\n                    raw.connections.forEach({\n                        \"useMoviesData.useEffect.fetchData\": (conn)=>{\n                            if (!similarityMap[conn.source]) {\n                                similarityMap[conn.source] = {\n                                    similarTo: [],\n                                    similarityScores: {}\n                                };\n                            }\n                            similarityMap[conn.source].similarTo.push(conn.target);\n                            similarityMap[conn.source].similarityScores[conn.target] = conn.similarity;\n                            // Bidirectional (optional depending on your logic)\n                            if (!similarityMap[conn.target]) {\n                                similarityMap[conn.target] = {\n                                    similarTo: [],\n                                    similarityScores: {}\n                                };\n                            }\n                            similarityMap[conn.target].similarTo.push(conn.source);\n                            similarityMap[conn.target].similarityScores[conn.source] = conn.similarity;\n                        }\n                    }[\"useMoviesData.useEffect.fetchData\"]);\n                    // First pass: create movie objects with basic properties\n                    const processedMovies = raw.movies.map({\n                        \"useMoviesData.useEffect.fetchData.processedMovies\": (movie)=>{\n                            const { similarTo = [], similarityScores = {} } = similarityMap[movie.id] || {};\n                            return {\n                                id: movie.id,\n                                title: movie.title,\n                                year: movie.year || \"\",\n                                x: 0,\n                                y: 0,\n                                radius: 8 + Math.min(5, similarTo.length / 3),\n                                color: getColor(movie.genres),\n                                genres: movie.genres,\n                                similarTo,\n                                similarityScores,\n                                // Add visibility property for fade effects\n                                visibility: 1\n                            };\n                        }\n                    }[\"useMoviesData.useEffect.fetchData.processedMovies\"]);\n                    // Apply force-directed layout\n                    const positionedMovies = applyForceLayout(processedMovies);\n                    setMovies(positionedMovies);\n                } catch (err) {\n                    console.error('Failed to load constellation data:', err);\n                }\n            }\n            fetchData();\n        }\n    }[\"useMoviesData.useEffect\"], []);\n    return movies;\n}\n_s(useMoviesData, \"MO6b3PSP3RIUqZ8gtSrBZBVtBbs=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9Nb3ZpZURhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUM0QztBQUU1QyxnQ0FBZ0M7QUFDaEMsTUFBTUUsY0FBYztJQUNsQkMsUUFBUTtJQUNSLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLFVBQVU7SUFDVkMsU0FBUztJQUNUQyxTQUFTO0lBQ1RDLE9BQU87SUFDUEMsVUFBVTtJQUNWQyxTQUFTO0FBQ1g7QUFFQSxTQUFTQyxTQUFTQyxNQUFNO0lBQ3RCLHNEQUFzRDtJQUN0RCxLQUFLLE1BQU1DLEtBQUtELE9BQVE7UUFDdEIsSUFBSVgsV0FBVyxDQUFDWSxFQUFFLEVBQUUsT0FBT1osV0FBVyxDQUFDWSxFQUFFO0lBQzNDO0lBQ0EsT0FBTztBQUNUO0FBRUEsdUNBQXVDO0FBQ3ZDLFNBQVNDLGlCQUFpQkMsTUFBTTtRQUFFQyxhQUFBQSxpRUFBYTtJQUM3QyxNQUFNQyxRQUFRQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLFNBQVMsQ0FBQ0w7SUFFeEMsTUFBTU0sSUFBSSxJQUFJLDZDQUE2QztJQUMzRCxNQUFNQyxjQUFjQyxPQUFPQyxVQUFVO0lBQ3JDLE1BQU1DLGVBQWVGLE9BQU9HLFdBQVc7SUFFdkNULE1BQU1VLE9BQU8sQ0FBQyxDQUFDQyxNQUFNQztRQUNuQixNQUFNQyxXQUFXQyxLQUFLQyxJQUFJLENBQUNELEtBQUtFLElBQUksQ0FBQ2hCLE1BQU1pQixNQUFNO1FBQ2pELE1BQU1DLE1BQU1OLElBQUlDO1FBQ2hCLE1BQU1NLE1BQU1MLEtBQUtNLEtBQUssQ0FBQ1IsSUFBSUM7UUFFM0IsTUFBTVEsVUFBVWhCLGNBQWMsS0FBSyxpQkFBaUI7UUFDcEQsTUFBTWlCLFVBQVVkLGVBQWU7UUFFL0JHLEtBQUtZLENBQUMsR0FBRyxjQUFlLE1BQU8sTUFBT1YsV0FBWVE7UUFDbERWLEtBQUthLENBQUMsR0FBRyxlQUFnQixNQUFPLE1BQU9YLFdBQVlTO1FBRW5E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QUt6QixVQUFVO3dCQUM1RTs7b0JBRUEseURBQXlEO29CQUN6RCxNQUFNNkIsa0JBQWtCVixJQUFJM0QsTUFBTSxDQUFDc0UsR0FBRzs2RUFBQ1IsQ0FBQUE7NEJBQ3JDLE1BQU0sRUFBRXpCLFlBQVksRUFBRSxFQUFFSSxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsR0FBR3NCLGFBQWEsQ0FBQ0QsTUFBTXZCLEVBQUUsQ0FBQyxJQUFJLENBQUM7NEJBQzlFLE9BQU87Z0NBQ0xBLElBQUl1QixNQUFNdkIsRUFBRTtnQ0FDWmdDLE9BQU9ULE1BQU1TLEtBQUs7Z0NBQ2xCQyxNQUFNVixNQUFNVSxJQUFJLElBQUk7Z0NBQ3BCL0MsR0FBRztnQ0FDSEMsR0FBRztnQ0FDSHdCLFFBQVEsSUFBSWxDLEtBQUt5RCxHQUFHLENBQUMsR0FBSXBDLFVBQVVsQixNQUFNLEdBQUc7Z0NBQzVDdUQsT0FBTzlFLFNBQVNrRSxNQUFNakUsTUFBTTtnQ0FDNUJBLFFBQVFpRSxNQUFNakUsTUFBTTtnQ0FDcEJ3QztnQ0FDQUk7Z0NBQ0EsMkNBQTJDO2dDQUMzQ2tDLFlBQVk7NEJBQ2Q7d0JBQ0Y7O29CQUVBLDhCQUE4QjtvQkFDOUIsTUFBTUMsbUJBQW1CN0UsaUJBQWlCc0U7b0JBRTFDZCxVQUFVcUI7Z0JBQ1osRUFBRSxPQUFPQyxLQUFLO29CQUNaQyxRQUFRQyxLQUFLLENBQUMsc0NBQXNDRjtnQkFDdEQ7WUFDRjtZQUVBckI7UUFDRjtrQ0FBRyxFQUFFO0lBRUwsT0FBT3hEO0FBQ1Q7R0FoRXdCc0QiLCJzb3VyY2VzIjpbIi9ob21lL3NhaGEvYmRhMjUvY2luZS1zdGVsbGF0aW9uL2NpbmUtc3RlbGxhdGlvbi9jbGllbnQvc3JjL2FwcC9jb21wb25lbnRzL01vdmllRGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbi8vIE9wdGlvbmFsOiBnZW5yZSBjb2xvciBtYXBwaW5nXG5jb25zdCBnZW5yZUNvbG9ycyA9IHtcbiAgQ29tZWR5OiAnI2YxZmE4YycsXG4gICdTY2ktRmknOiAnIzhiZTlmZCcsXG4gIEFkdmVudHVyZTogJyM1MGZhN2InLFxuICBBbmltYXRpb246ICcjYmQ5M2Y5JyxcbiAgQ2hpbGRyZW46ICcjZmY3OWM2JyxcbiAgRmFudGFzeTogJyNmZmI4NmMnLFxuICBSb21hbmNlOiAnI2ZmNTU1NScsXG4gIERyYW1hOiAnIzYyNzJhNCcsXG4gIFRocmlsbGVyOiAnI2ZmNzljNicsXG4gIE15c3Rlcnk6ICcjZmZiODZjJyxcbn07XG5cbmZ1bmN0aW9uIGdldENvbG9yKGdlbnJlcykge1xuICAvLyBQaWNrIGZpcnN0IGdlbnJlIHRoYXQgaGFzIGEgY29sb3IsIGZhbGxiYWNrIHRvIGdyYXlcbiAgZm9yIChjb25zdCBnIG9mIGdlbnJlcykge1xuICAgIGlmIChnZW5yZUNvbG9yc1tnXSkgcmV0dXJuIGdlbnJlQ29sb3JzW2ddO1xuICB9XG4gIHJldHVybiAnI2NjY2NjYyc7XG59XG5cbi8vIEZvcmNlLWRpcmVjdGVkIHBvc2l0aW9uaW5nIGFsZ29yaXRobVxuZnVuY3Rpb24gYXBwbHlGb3JjZUxheW91dChtb3ZpZXMsIGl0ZXJhdGlvbnMgPSA1MCkge1xuICBjb25zdCBub2RlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobW92aWVzKSk7XG5cbiAgY29uc3QgayA9IDE1OyAvLyBzbWFsbGVyIG9wdGltYWwgZGlzdGFuY2UgPT4gdGlnaHRlciBsYXlvdXRcbiAgY29uc3QgY2FudmFzV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgY29uc3QgY2FudmFzSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gIG5vZGVzLmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICBjb25zdCBncmlkU2l6ZSA9IE1hdGguY2VpbChNYXRoLnNxcnQobm9kZXMubGVuZ3RoKSk7XG4gICAgY29uc3QgY29sID0gaSAlIGdyaWRTaXplO1xuICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoaSAvIGdyaWRTaXplKTtcblxuICAgIGNvbnN0IHNwcmVhZFggPSBjYW52YXNXaWR0aCAqIDAuNDsgLy8gcmVkdWNlZCBzcHJlYWRcbiAgICBjb25zdCBzcHJlYWRZID0gY2FudmFzSGVpZ2h0ICogMC40O1xuXG4gICAgbm9kZS54ID0gKGNhbnZhc1dpZHRoICogMC4zKSArIChjb2wgLyBncmlkU2l6ZSkgKiBzcHJlYWRYO1xuICAgIG5vZGUueSA9IChjYW52YXNIZWlnaHQgKiAwLjMpICsgKHJvdyAvIGdyaWRTaXplKSAqIHNwcmVhZFk7XG5cbiAgICBub2RlLnZ4ID0gMDtcbiAgICBub2RlLnZ5ID0gMDtcbiAgfSk7XG5cbiAgZm9yIChsZXQgaXRlciA9IDA7IGl0ZXIgPCBpdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBub2RlMSA9IG5vZGVzW2ldO1xuICAgICAgICBjb25zdCBub2RlMiA9IG5vZGVzW2pdO1xuXG4gICAgICAgIGNvbnN0IGR4ID0gbm9kZTIueCAtIG5vZGUxLng7XG4gICAgICAgIGNvbnN0IGR5ID0gbm9kZTIueSAtIG5vZGUxLnk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSB8fCAxO1xuXG4gICAgICAgIGxldCBmb3JjZSA9IGsgKiBrIC8gZGlzdGFuY2U7XG5cbiAgICAgICAgaWYgKG5vZGUxLnNpbWlsYXJUbyAmJiBub2RlMS5zaW1pbGFyVG8uaW5jbHVkZXMobm9kZTIuaWQpKSB7XG4gICAgICAgICAgY29uc3Qgc2ltaWxhcml0eSA9IG5vZGUxLnNpbWlsYXJpdHlTY29yZXNbbm9kZTIuaWRdIHx8IDAuNTtcbiAgICAgICAgICBmb3JjZSAqPSAoMSAtIHNpbWlsYXJpdHkgKiAwLjcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgIGNvbnN0IGZvcmNlWCA9IChkeCAvIGRpc3RhbmNlKSAqIGZvcmNlO1xuICAgICAgICAgIGNvbnN0IGZvcmNlWSA9IChkeSAvIGRpc3RhbmNlKSAqIGZvcmNlO1xuXG4gICAgICAgICAgbm9kZTEudnggLT0gZm9yY2VYO1xuICAgICAgICAgIG5vZGUxLnZ5IC09IGZvcmNlWTtcbiAgICAgICAgICBub2RlMi52eCArPSBmb3JjZVg7XG4gICAgICAgICAgbm9kZTIudnkgKz0gZm9yY2VZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgaWYgKG5vZGUuc2ltaWxhclRvICYmIG5vZGUuc2ltaWxhclRvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBub2RlLnNpbWlsYXJUbykge1xuICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gdGFyZ2V0SWQpO1xuICAgICAgICAgIGlmICh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBkeCA9IHRhcmdldE5vZGUueCAtIG5vZGUueDtcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gdGFyZ2V0Tm9kZS55IC0gbm9kZS55O1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIHx8IDE7XG5cbiAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBub2RlLnNpbWlsYXJpdHlTY29yZXNbdGFyZ2V0SWRdIHx8IDAuNTtcbiAgICAgICAgICAgIGNvbnN0IGZvcmNlID0gZGlzdGFuY2UgKiBzaW1pbGFyaXR5ICogMC4wNzsgLy8gc2xpZ2h0bHkgc3Ryb25nZXIgYXR0cmFjdGlvblxuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZvcmNlWCA9IChkeCAvIGRpc3RhbmNlKSAqIGZvcmNlO1xuICAgICAgICAgICAgICBjb25zdCBmb3JjZVkgPSAoZHkgLyBkaXN0YW5jZSkgKiBmb3JjZTtcblxuICAgICAgICAgICAgICBub2RlLnZ4ICs9IGZvcmNlWDtcbiAgICAgICAgICAgICAgbm9kZS52eSArPSBmb3JjZVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBub2RlLnggKz0gbm9kZS52eDtcbiAgICAgIG5vZGUueSArPSBub2RlLnZ5O1xuXG4gICAgICBjb25zdCBwYWRkaW5nID0gMjA7IC8vIHRpZ2h0ZXIgYm91bmRhcnlcbiAgICAgIGlmIChub2RlLnggPCBwYWRkaW5nKSBub2RlLnZ4ICs9IDE7XG4gICAgICBpZiAobm9kZS54ID4gY2FudmFzV2lkdGggLSBwYWRkaW5nKSBub2RlLnZ4IC09IDE7XG4gICAgICBpZiAobm9kZS55IDwgcGFkZGluZykgbm9kZS52eSArPSAxO1xuICAgICAgaWYgKG5vZGUueSA+IGNhbnZhc0hlaWdodCAtIHBhZGRpbmcpIG5vZGUudnkgLT0gMTtcblxuICAgICAgbm9kZS52eCAqPSAwLjk7XG4gICAgICBub2RlLnZ5ICo9IDAuOTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IG5vZGUxID0gbm9kZXNbaV07XG4gICAgICBjb25zdCBub2RlMiA9IG5vZGVzW2pdO1xuXG4gICAgICBjb25zdCBkeCA9IG5vZGUyLnggLSBub2RlMS54O1xuICAgICAgY29uc3QgZHkgPSBub2RlMi55IC0gbm9kZTEueTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGNvbnN0IG1pbkRpc3RhbmNlID0gbm9kZTEucmFkaXVzICsgbm9kZTIucmFkaXVzICsgMztcblxuICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmxhcCA9IG1pbkRpc3RhbmNlIC0gZGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IG1vdmVYID0gKGR4IC8gZGlzdGFuY2UpICogb3ZlcmxhcCAqIDAuNTtcbiAgICAgICAgY29uc3QgbW92ZVkgPSAoZHkgLyBkaXN0YW5jZSkgKiBvdmVybGFwICogMC41O1xuXG4gICAgICAgIG5vZGUxLnggLT0gbW92ZVg7XG4gICAgICAgIG5vZGUxLnkgLT0gbW92ZVk7XG4gICAgICAgIG5vZGUyLnggKz0gbW92ZVg7XG4gICAgICAgIG5vZGUyLnkgKz0gbW92ZVk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZU1vdmllc0RhdGEoKSB7XG4gIGNvbnN0IFttb3ZpZXMsIHNldE1vdmllc10gPSB1c2VTdGF0ZShbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2NvbnN0ZWxsYXRpb25fZGF0YS5qc29uJyk7XG4gICAgICAgIGNvbnN0IHJhdyA9IGF3YWl0IHJlcy5qc29uKCk7XG5cbiAgICAgICAgLy8gTWFwIG9mIG1vdmllSWQgPT4gbW92aWVEYXRhXG4gICAgICAgIGNvbnN0IG1vdmllTWFwID0ge307XG4gICAgICAgIHJhdy5tb3ZpZXMuZm9yRWFjaChtb3ZpZSA9PiB7XG4gICAgICAgICAgbW92aWVNYXBbbW92aWUuaWRdID0gbW92aWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFByZXBhcmUgc2ltaWxhcml0eSBsb29rdXA6IG1vdmllSWQgPT4geyBzaW1pbGFyVG86IFsuLi5dLCBzaW1pbGFyaXR5U2NvcmVzOiB7Li4ufSB9XG4gICAgICAgIGNvbnN0IHNpbWlsYXJpdHlNYXAgPSB7fTtcbiAgICAgICAgcmF3LmNvbm5lY3Rpb25zLmZvckVhY2goY29ubiA9PiB7XG4gICAgICAgICAgaWYgKCFzaW1pbGFyaXR5TWFwW2Nvbm4uc291cmNlXSkge1xuICAgICAgICAgICAgc2ltaWxhcml0eU1hcFtjb25uLnNvdXJjZV0gPSB7IHNpbWlsYXJUbzogW10sIHNpbWlsYXJpdHlTY29yZXM6IHt9IH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpbWlsYXJpdHlNYXBbY29ubi5zb3VyY2VdLnNpbWlsYXJUby5wdXNoKGNvbm4udGFyZ2V0KTtcbiAgICAgICAgICBzaW1pbGFyaXR5TWFwW2Nvbm4uc291cmNlXS5zaW1pbGFyaXR5U2NvcmVzW2Nvbm4udGFyZ2V0XSA9IGNvbm4uc2ltaWxhcml0eTtcblxuICAgICAgICAgIC8vIEJpZGlyZWN0aW9uYWwgKG9wdGlvbmFsIGRlcGVuZGluZyBvbiB5b3VyIGxvZ2ljKVxuICAgICAgICAgIGlmICghc2ltaWxhcml0eU1hcFtjb25uLnRhcmdldF0pIHtcbiAgICAgICAgICAgIHNpbWlsYXJpdHlNYXBbY29ubi50YXJnZXRdID0geyBzaW1pbGFyVG86IFtdLCBzaW1pbGFyaXR5U2NvcmVzOiB7fSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaW1pbGFyaXR5TWFwW2Nvbm4udGFyZ2V0XS5zaW1pbGFyVG8ucHVzaChjb25uLnNvdXJjZSk7XG4gICAgICAgICAgc2ltaWxhcml0eU1hcFtjb25uLnRhcmdldF0uc2ltaWxhcml0eVNjb3Jlc1tjb25uLnNvdXJjZV0gPSBjb25uLnNpbWlsYXJpdHk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpcnN0IHBhc3M6IGNyZWF0ZSBtb3ZpZSBvYmplY3RzIHdpdGggYmFzaWMgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRNb3ZpZXMgPSByYXcubW92aWVzLm1hcChtb3ZpZSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBzaW1pbGFyVG8gPSBbXSwgc2ltaWxhcml0eVNjb3JlcyA9IHt9IH0gPSBzaW1pbGFyaXR5TWFwW21vdmllLmlkXSB8fCB7fTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IG1vdmllLmlkLFxuICAgICAgICAgICAgdGl0bGU6IG1vdmllLnRpdGxlLFxuICAgICAgICAgICAgeWVhcjogbW92aWUueWVhciB8fCBcIlwiLCAvLyBBZGQgeWVhciBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIHg6IDAsIC8vIFdpbGwgYmUgcG9zaXRpb25lZCBieSBmb3JjZSBsYXlvdXRcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICByYWRpdXM6IDggKyBNYXRoLm1pbig1LCAoc2ltaWxhclRvLmxlbmd0aCAvIDMpKSwgLy8gUmFkaXVzIGJhc2VkIG9uIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICBjb2xvcjogZ2V0Q29sb3IobW92aWUuZ2VucmVzKSxcbiAgICAgICAgICAgIGdlbnJlczogbW92aWUuZ2VucmVzLFxuICAgICAgICAgICAgc2ltaWxhclRvLFxuICAgICAgICAgICAgc2ltaWxhcml0eVNjb3JlcyxcbiAgICAgICAgICAgIC8vIEFkZCB2aXNpYmlsaXR5IHByb3BlcnR5IGZvciBmYWRlIGVmZmVjdHNcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IDFcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IGZvcmNlLWRpcmVjdGVkIGxheW91dFxuICAgICAgICBjb25zdCBwb3NpdGlvbmVkTW92aWVzID0gYXBwbHlGb3JjZUxheW91dChwcm9jZXNzZWRNb3ZpZXMpO1xuICAgICAgICBcbiAgICAgICAgc2V0TW92aWVzKHBvc2l0aW9uZWRNb3ZpZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNvbnN0ZWxsYXRpb24gZGF0YTonLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZldGNoRGF0YSgpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIG1vdmllcztcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImdlbnJlQ29sb3JzIiwiQ29tZWR5IiwiQWR2ZW50dXJlIiwiQW5pbWF0aW9uIiwiQ2hpbGRyZW4iLCJGYW50YXN5IiwiUm9tYW5jZSIsIkRyYW1hIiwiVGhyaWxsZXIiLCJNeXN0ZXJ5IiwiZ2V0Q29sb3IiLCJnZW5yZXMiLCJnIiwiYXBwbHlGb3JjZUxheW91dCIsIm1vdmllcyIsIml0ZXJhdGlvbnMiLCJub2RlcyIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImsiLCJjYW52YXNXaWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJpbm5lckhlaWdodCIsImZvckVhY2giLCJub2RlIiwiaSIsImdyaWRTaXplIiwiTWF0aCIsImNlaWwiLCJzcXJ0IiwibGVuZ3RoIiwiY29sIiwicm93IiwiZmxvb3IiLCJzcHJlYWRYIiwic3ByZWFkWSIsIngiLCJ5IiwidngiLCJ2eSIsIml0ZXIiLCJqIiwibm9kZTEiLCJub2RlMiIsImR4IiwiZHkiLCJkaXN0YW5jZSIsImZvcmNlIiwic2ltaWxhclRvIiwiaW5jbHVkZXMiLCJpZCIsInNpbWlsYXJpdHkiLCJzaW1pbGFyaXR5U2NvcmVzIiwiZm9yY2VYIiwiZm9yY2VZIiwidGFyZ2V0SWQiLCJ0YXJnZXROb2RlIiwiZmluZCIsIm4iLCJwYWRkaW5nIiwibWluRGlzdGFuY2UiLCJyYWRpdXMiLCJvdmVybGFwIiwibW92ZVgiLCJtb3ZlWSIsInVzZU1vdmllc0RhdGEiLCJzZXRNb3ZpZXMiLCJmZXRjaERhdGEiLCJyZXMiLCJmZXRjaCIsInJhdyIsImpzb24iLCJtb3ZpZU1hcCIsIm1vdmllIiwic2ltaWxhcml0eU1hcCIsImNvbm5lY3Rpb25zIiwiY29ubiIsInNvdXJjZSIsInB1c2giLCJ0YXJnZXQiLCJwcm9jZXNzZWRNb3ZpZXMiLCJtYXAiLCJ0aXRsZSIsInllYXIiLCJtaW4iLCJjb2xvciIsInZpc2liaWxpdHkiLCJwb3NpdGlvbmVkTW92aWVzIiwiZXJyIiwiY29uc29sZSIsImVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/MovieData.js\n"));

/***/ })

});